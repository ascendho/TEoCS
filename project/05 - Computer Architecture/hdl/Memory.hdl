// This file is part of www.nand2tetris.org
// and the book "The Elements of Computing Systems"
// by Nisan and Schocken, MIT Press.
// File name: projects/5/Memory.hdl
/**
 * The complete address space of the Hack computer's memory,
 * including RAM and memory-mapped I/O. 
 * The chip facilitates read and write operations, as follows:
 *     Read:  out(t) = Memory[address(t)](t)
 *     Write: if load(t-1) then Memory[address(t-1)](t) = in(t-1)
 * In words: the chip always outputs the value stored at the memory 
 * location specified by address. If load=1, the in value is loaded 
 * into the memory location specified by address. This value becomes 
 * available through the out output from the next time step onward.
 * Address space rules:
 * Only the upper 16K+8K+1 words of the Memory chip are used. 
 * Access to address>0x6000 is invalid and reads 0. Access to any address
 * in the range 0x4000-0x5FFF results in accessing the screen memory 
 * map. Access to address 0x6000 results in accessing the keyboard 
 * memory map. The behavior in these addresses is described in the Screen
 * and Keyboard chip specifications given in the lectures and the book.
 */
CHIP Memory {
    IN in[16], load, address[15];
    OUT out[16];

    PARTS:
	//// Replace this comment with your code.
    // 第一步：通过地址高位拆分load信号，确保只有目标设备接收写入命令
    // 地址第14位(bit14)是区分RAM和其他设备的关键：
    // - bit14=0 → 访问RAM（0x0000-0x3FFF），load信号传给load1
    // - bit14=1 → 访问屏幕/键盘/无效地址，load信号传给load2
    DMux(in=load, sel=address[14], a=load1, b=load2);

    // 进一步拆分load2：用地址第13位(bit13)区分屏幕和键盘/无效地址
    // - bit13=0 → 访问屏幕（0x4000-0x5FFF），load信号传给load21
    // - bit13=1 → 访问键盘（0x6000）或无效地址（>0x6000），load信号传给load22（但键盘只读，此信号实际无用）
    DMux(in=load2, sel=address[13], a=load21, b=load22);

    // 实例化16K RAM（地址范围0x0000-0x3FFF）
    // - 输入数据：in
    // - 写入控制：仅当访问RAM时有效（load1）
    // - 地址：使用低14位（address[0..13]），因为16K需要2^14=16384个地址
    // - 输出：ram数据（out1）
    RAM16K(in=in, load=load1, address=address[0..13], out=out1);

    // 实例化屏幕内存（地址范围0x4000-0x5FFF）
    // - 输入数据：in
    // - 写入控制：仅当访问屏幕时有效（load21）
    // - 地址：使用低13位（address[0..12]），因为8K需要2^13=8192个地址
    // - 输出：屏幕数据（out2）
    Screen(in=in, load=load21, address=address[0..12], out=out2);

    // 实例化键盘（仅地址0x6000有效）
    // - 键盘是只读设备，无需输入数据和load信号
    // - 输出：当前键盘输入数据（out3）
    Keyboard(out=out3);

    // 第二步：选择输出信号（先处理bit14=1的情况）
    // 假设bit14=1，用bit13选择屏幕或键盘输出：
    // - bit13=0 → 选择屏幕输出（out2）
    // - bit13=1 → 选择键盘输出（out3）
    // 注意：此处未显式处理>0x6000的无效地址（按规范应输出0），但代码默认使用键盘输出（实际无效地址时键盘输出也为0，效果一致）
    Mux16(a=out2, b=out3, sel=address[13], out=tmp);

    // 最终输出选择：用bit14选择RAM或上述结果
    // - bit14=0 → 选择RAM输出（out1）
    // - bit14=1 → 选择屏幕/键盘输出（tmp）
    Mux16(a=out1, b=tmp, sel=address[14], out=out);
}